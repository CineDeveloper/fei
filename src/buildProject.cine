proc buildProject(data BinaryData)
    position := 0
    feiFileName .= [UInt8].getFromBinaryData(data, position)
    cCopyFileName .= [UInt8].getFromBinaryData(data, position)
    blocks .= feiFileName.loadBlocks(false)
    blocks[0].noSubBlocks!()
    if < blocks.getLength() == 0
        then errorNotExpectedEOL(Token{file: feiFileName}, "")
    isModule .= blocks[0].line[0][] == "module"
    if < isModule && cCopyFileName != ""
        then errorNotExpectedCMDArg("--ccopy", "")
    feiPath .= feiFileName.getPath()
    sourcesFiles .= feiPath.getSourcesFiles()
    modules .= feiPath.getModules()
    resources .= feiPath.getResources()
    if isModule
        then buildModule(blocks, sourcesFiles, modules, resources, feiPath)
        else
            tokenIndex := 0
            blocks[0].next!(tokenIndex, "program")
            buildProgram(blocks, sourcesFiles, modules, resources, feiFileName, cCopyFileName)

proc buildProgram(blocks [Block], sourcesFiles [[UInt8]], modules [Module], resources [Resource], feiFileName [UInt8], cCopyFileName [UInt8])
    //(bits 0 -> 2) flags, version, cCompilerOptions
    alreadyParsed := 0
    flags := [Pair(Token, Token)]
    version := [UInt8]
    cCompilerOptions := [UInt8]
    tokenIndex := 1
    programName .= blocks[0].getString(tokenIndex)
    blocks[0].eol!(tokenIndex)
    parse _, block <- blocks.getAllExceptFirst()
        error := false
        tokenIndex = 0
        firstToken .= block.next(tokenIndex)
        case firstToken[] of
            "flags"
                if < (alreadyParsed & 1) == 1
                    then
                        error = true
                        break
                alreadyParsed |= 1
                if block.subBlocks.getLength() != 0
                    then flags = block.subBlocks.getFlags()
            "version"
                if < (alreadyParsed & 2) == 2
                    then
                        error = true
                        break
                alreadyParsed |= 2
                version = block.getVersion()
                tokenIndex++
            "cCompilerOptions"
                if < (alreadyParsed & 4) == 4
                    then
                        error = true
                        break
                alreadyParsed |= 4
                cCompilerOptions = block.getCCompilerOptions()
                tokenIndex++
            default
                error = true
        if < error
            then errorNotExpectedToken(firstToken, "")
    if < alreadyParsed != 7
        then errorMissedSection(feiFileName)
    printLn("Building...")
    uniqueModules .= modules.unique()
    allResources .= resources + uniqueModules.getResources()
    allResources.unique!()
    cFile_flagsFile .= sourcesFiles.compileSources(uniqueModules.getOneCineFile(), programName)
    buildProgramPackage(cFile_flagsFile.first, cFile_flagsFile.second, allResources, flags, version, cCompilerOptions, programName, feiFileName, cCopyFileName)
    printLn("Done.")
    _ = cFile_flagsFile.first.getPath().deleteDirectory(true)

func compileSources(sourcesFiles [[UInt8]], modulesCode [UInt8], programName [UInt8]) Pair([UInt8], [UInt8])
    tmpDirectory .= "/tmp/" + programName + "/"
    cFile .= tmpDirectory.join(programName, ".c")
    flagsFile .= tmpDirectory + "flags"
    modulesCodeFile .= tmpDirectory + "modules.cine"
    if < !makeDirectory(tmpDirectory, true)
        then errorCantMakeDirectory(tmpDirectory)
    makeFile(modulesCodeFile, modulesCode)
    execString := "cine -i " + modulesCodeFile
    parse _, file <- sourcesFiles
        execString:join(" ", file)
    execString:join(" -o ", cFile, " -f ", flagsFile)
    panic(!systemExecute(execString), "")
    result = #result.create(cFile, flagsFile)

proc buildProgramPackage(cFileName [UInt8], programFlagsFileName [UInt8], resources [Resource], feiFlags [Pair(Token, Token)], version [UInt8], cCompilerOptions [UInt8], programName [UInt8], feiFileName [UInt8], cCopyFileName [UInt8])
    package := ProgramPackage
    package:name = programName
    package:version = version
    cFileBox .= cFileName.loadFile()
    programFlagsFileBox .= programFlagsFileName.loadFile()
    if < cFileBox.empty?() || programFlagsFileBox.empty?()
        then errorSourcesNotCompiled()
    programFlagsFile .= programFlagsFileBox[]
    position := 0
    programFlags := Map([UInt8], Flag)
    for flagsLength := UInt64.getFromBinaryData(programFlagsFile, position); flagsLength != 0; flagsLength--
        name .= [UInt8].getFromBinaryData(programFlagsFile, position)
        flag_ .= Flag.getFromBinaryData(programFlagsFile, position)
        programFlags:add(name, flag_)
    cFile := ""
    parse _, feiFlag <- feiFlags
        programFlagBox .= programFlags[feiFlag.first[]]
        if < programFlagBox.empty?()
            then errorNotExist(feiFlag.first, "flag")
        programFlags -= feiFlag.first[]
        variantIsValid := false
        parse variantNumber, variant <- programFlagBox[].variants
            if variant == feiFlag.second[]
                then
                    variantIsValid = true
                    cFile:join("#define __FLAG_", feiFlag.first[], " ", variantNumber.toString(), "\n")
                    break
        if < !variantIsValid
            then errorNotExist(feiFlag.second, "flag variant")
    cFile += cFileBox[].convertTo([UInt8])
    if cCopyFileName != ""
        then makeFile(cCopyFileName, cFile)
    package:cCode = cFile
    flagsFile := BinaryData
    flagsFile += programFlags.getLength()
    parse name, flag_ <- programFlags
        flagsFile += name
        flagsFile += flag_
    package:flagsFile = flagsFile
    package:cCompilerOptions = cCompilerOptions
    package:resources = resources
    feiPath .= feiFileName.getPath()
    _ = makeDirectory(feiPath + "pkgs", true)
    package.save(feiPath.join("pkgs/", programName, "-", version, ".fpkg"))

proc buildModule(blocks [Block], sourcesFiles [[UInt8]], modules [Module], resources [Resource], feiPath [UInt8])
    if < blocks.getLength() > 2
        then errorNotExpectedToken(blocks[2].line[0], "")
    tokenIndex := 1
    moduleNameBlock .= blocks[0]
    moduleName .= moduleNameBlock.getString(tokenIndex)
    moduleNameBlock.eol!(tokenIndex)
    if < blocks.getLength() == 1
        then errorNotExpectedToken(Token{file: moduleNameBlock.line[0].file, line: moduleNameBlock.line[0].line + 1, value: "[Nothing]"}, "version")
    tokenIndex = 0
    version .= blocks[1].getVersion()
    printLn("Building...")
    buildModulePackage(sourcesFiles.getSources(), modules, resources, moduleName, version, feiPath)
    printLn("Done.")

func getSourcesFiles(feiPath [UInt8]) [[UInt8]]
    sourcesPath .= feiPath.add("src")
    sourcesBox .= sourcesPath.getDirectoryItems()
    if < sourcesBox.empty?()
        then errorWrongDirectory(sourcesPath)
    parse _, source <- sourcesBox[]
        if !source.second && source.first.hasSuffix?(".cine")
            then result += source.first

func getSources(sourcesFiles [[UInt8]]) [UInt8]
    blocks := [Block]
    parse _, source <- sourcesFiles
        blocks += source.loadBlocks(true)
    blocks:sort(builtInGetFunctionByID("block less function", @(Block, Block) -> Bool))
    result += blocks.toString()

func getModules(feiPath [UInt8]) [Module]
    modulesPath .= feiPath.add("modules")
    modulesBox .= modulesPath.getDirectoryItems()
    if modulesBox.item?()
        then parse _, module <- modulesBox[]
            if !module.second && module.first.hasSuffix?(".fpkg")
                then result += ModulePackage.load(module.first).modules

func getResources(feiPath [UInt8]) [Resource]
    resourcesPath .= feiPath.add("resources")
    resourcesBox .= resourcesPath.getDirectoryItems()
    unneededLength .= resourcesPath.getLength() + 1
    if resourcesBox.item?()
        then parse _, resource <- resourcesBox[]
            resourceName .= resource.first.getAllExceptFirstN(unneededLength)
            if resource.second
                then result += Resource{name: resourceName}
                else if resourceBox .= loadFile(resource.first); > resourceBox.item?()
                    then result += Resource{name: resourceName, data: Box([UInt8]).create(resourceBox[].convertTo([UInt8]))}
                    else errorCantLoadFile(resource.first)

proc buildModulePackage(sources [UInt8], modules [Module], resources [Resource], moduleName [UInt8], version [UInt8], feiPath [UInt8])
    package .= ModulePackage{
        {name: moduleName,
        version: version,
        modules: (modules + Module{name: moduleName, version: version, code: sources, resources: resources}).unique()}
    }
    package.modules.getResources().unique!()
    _ = makeDirectory(feiPath + "pkgs", true)
    package.save(feiPath.join("pkgs/", moduleName, "-", version, ".fpkg"))
