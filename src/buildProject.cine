proc buildProject(data BinaryData)
    //(bits 0 -> 4) sources, flags, version, cCompilerOptions, executable
    position := 0
    feiFileName .= [UInt8].getFromBinaryData(data, position)
    cCopeFileName .= [UInt8].getFromBinaryData(data, position)
    alreadyParsed := 0
    sources := [[UInt8]]
    flags := [Pair(Token, Token)]
    version := [UInt8]
    cCompilerOptions := [UInt8]
    executable := [UInt8]
    parse _, block <- feiFileName.loadBlocks()
        error := false
        tokenIndex := 0
        firstToken .= block.next(tokenIndex)
        case firstToken[] of
            "sources"
                if < (alreadyParsed & 1) == 1
                    then
                        error = true
                        break
                alreadyParsed |= 1
                block.subBlocks!()
                sources = block.subBlocks.getSources(feiFileName)
            "flags"
                if < (alreadyParsed & 2) == 2
                    then
                        error = true
                        break
                alreadyParsed |= 2
                if block.subBlocks.getLength() != 0
                    then flags = block.subBlocks.getFlags()
            "version"
                if < (alreadyParsed & 4) == 4
                    then
                        error = true
                        break
                alreadyParsed |= 4
                block.noSubBlocks!()
                version = block.getVersion()
                tokenIndex++
            "cCompilerOptions"
                if < (alreadyParsed & 8) == 8
                    then
                        error = true
                        break
                alreadyParsed |= 8
                block.noSubBlocks!()
                cCompilerOptions = block.getCCompilerOptions()
                tokenIndex++
            "executable"
                if < (alreadyParsed & 16) == 16
                    then
                        error = true
                        break
                alreadyParsed |= 16
                block.noSubBlocks!()
                executable = block.getExecutable()
                tokenIndex++
            default
                error = true
        if < error
            then errorNotExpectedToken(firstToken, "")
    if < alreadyParsed != 31
        then errorMissedSection(feiFileName)
    cFile_flagsFile .= sources.compile(executable)
    buildPackage(cFile_flagsFile.first, cFile_flagsFile.second, flags, version, cCompilerOptions, executable, feiFileName, cCopeFileName)
    _ = cFile_flagsFile.first.getPath().deleteDirectory(true)

func compile(sources [[UInt8]], executable [UInt8]) Pair([UInt8], [UInt8])
    tmpDirectory .= "/tmp/" + executable + "/"
    cFile .= tmpDirectory.join(executable, ".c")
    flagsFile .= tmpDirectory + "flags"
    if < !makeDirectory(tmpDirectory, true)
        then errorCantMakeDirectory(tmpDirectory)
    execString := "cine -i"
    parse _, file <- sources
        execString:join(" ", file)
    execString:join(" -o ", cFile, " -f ", flagsFile)
    panic(!systemExecute(execString), "")
    result = Pair([UInt8], [UInt8]).create(cFile, flagsFile)

proc buildPackage(cFileName [UInt8], programFlagsFileName [UInt8], feiFlags [Pair(Token, Token)], version [UInt8], cCompilerOptions [UInt8], executable [UInt8], feiFileName [UInt8], cCopeFileName [UInt8])
    package := BinaryData
    cFileBox .= cFileName.loadFile()
    programFlagsFileBox .= programFlagsFileName.loadFile()
    if < cFileBox.empty?() || programFlagsFileBox.empty?()
        then errorSourcesNotCompiled()
    programFlagsFile .= programFlagsFileBox[]
    position := 0
    programFlags := Map([UInt8], Flag)
    for flagsLength := UInt64.getFromBinaryData(programFlagsFile, position); flagsLength != 0; flagsLength--
        name .= [UInt8].getFromBinaryData(programFlagsFile, position)
        flag_ .= Flag.getFromBinaryData(programFlagsFile, position)
        programFlags:add(name, flag_)
    cFile := ""
    parse _, feiFlag <- feiFlags
        programFlagBox .= programFlags[feiFlag.first[]]
        if < programFlagBox.empty?()
            then errorNotExist(feiFlag.first, "flag")
        programFlags -= feiFlag.first[]
        variantIsValid := false
        parse variantNumber, variant <- programFlagBox[].variants
            if variant == feiFlag.second[]
                then
                    variantIsValid = true
                    cFile:join("#define __FLAG_", feiFlag.first[], " ", variantNumber.toString(), "\n")
                    break
        if < !variantIsValid
            then errorNotExist(feiFlag.second, "flag variant")
    cFile += cFileBox[].convertTo([UInt8])
    if cCopeFileName != ""
        then makeFile(cCopeFileName, cFile)
    package += cFile
    flags := BinaryData
    flags += programFlags.getLength()
    parse name, flag_ <- programFlags
        flags += name
        flags += flag_
    package += flags.convertTo([UInt8])
    package += cCompilerOptions
    package += version
    package += executable
    feiPathName .= feiFileName.getPath()
    feiFileNameWithoutPath .= feiFileName.getWithoutPath()
    packageFileName .= feiPathName.join("pkgs/", select(feiFileNameWithoutPath.hasSuffix?(".fei"), feiFileNameWithoutPath.getAllExceptLastN(4), feiFileNameWithoutPath), ".fpkg")
    _ = makeDirectory(feiPathName + "pkgs", true)
    if < !package.writeToFile(packageFileName)
        then errorCantWriteToFile(packageFileName)
