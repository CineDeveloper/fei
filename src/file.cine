func getBlock(file [[UInt8]], levelError Bool, expectedLevel UInt64, fileName [UInt8], :lineIndex UInt64, includeCAndInclude Bool) Box(Block)
    lineIndex = file.getFirstNotEmptyLineIndex(fileName, lineIndex)
    if lineIndex < file.getLength()
        then
            line := file[lineIndex]
            currentLevel := line.getLevel()
            if currentLevel != expectedLevel
                then if < levelError
                    then errorWrongLevel(fileName, lineIndex, expectedLevel, currentLevel)
                else
                    tokens := line.getAllTokens(fileName, lineIndex, currentLevel)
                    lineIndex++
                    ignoreSplitedString := false
                    mif
                        tokens[0][] == "C" && tokens.getLength() == 1 && includeCAndInclude
                            ignoreSplitedString = true
                            tokens = file.getCCode(expectedLevel + 1, fileName, lineIndex)
                        tokens[0][] == "include" && tokens.getLength() == 1 && includeCAndInclude
                            ignoreSplitedString = true
                            tokens = file.getCLibs(expectedLevel + 1, fileName, lineIndex)
                        tokens.getLast()[] == "{"
                            tokens = tokens.getAllExceptLast()
                            for
                                lineIndex = file.getFirstNotEmptyLineIndex(fileName, lineIndex)
                                if < lineIndex >= file.getLength()
                                    then errorNotExpectedToken(tokens.getLast(), "}")
                                line = file[lineIndex]
                                currentLevel = line.getLevel()
                                newTokens .= line.getAllTokens(fileName, lineIndex, currentLevel)
                                if newTokens.getLength() == 1 && newTokens.getLast()[] == "}"
                                    then
                                        lineIndex++
                                        break
                                    else tokens += newTokens
                                lineIndex++
                    if !ignoreSplitedString
                        then
                            leftIndexOfMultiString := 0
                            rightEdgeOfMultiString := 0
                            index := 0
                            for
                                for ; index + 1 < tokens.getLength(); index++
                                    if tokens[index][][0] == '\042' && tokens[index + 1][][0] == '\042'
                                        then
                                            leftIndexOfMultiString = index
                                            for rightEdgeOfMultiString = index + 2; rightEdgeOfMultiString < tokens.getLength(); rightEdgeOfMultiString++
                                                if tokens[rightEdgeOfMultiString][][0] != '\042'
                                                    then break
                                            index = rightEdgeOfMultiString
                                            break
                                if leftIndexOfMultiString == rightEdgeOfMultiString
                                    then break
                                    else
                                        newItem := tokens[leftIndexOfMultiString]
                                        newItem:value = newItem[].getAllExceptLast()
                                        for stringIndex := leftIndexOfMultiString + 1; stringIndex < rightEdgeOfMultiString; stringIndex++
                                            newItem:value += tokens[stringIndex][].getAllExceptLast().getAllExceptFirst()
                                        newItem:value += '\042'
                                        leftPart .= tokens.getFirstN(leftIndexOfMultiString)
                                        rightPart .= tokens.getAllExceptFirstN(rightEdgeOfMultiString)
                                        tokens = leftPart + newItem + rightPart
                                        leftIndexOfMultiString = 0
                                        rightEdgeOfMultiString = 0
                    result = #result.create(Block{line: tokens, subBlocks: file.getSubBlocks(expectedLevel + 1, fileName, lineIndex, includeCAndInclude)})

func getFirstNotEmptyLineIndex(file [[UInt8]], fileName [UInt8], currentLineIndex UInt64) UInt64
    result = currentLineIndex
    for result < file.getLength()
        if line .= file[result]; mutUInt64 := 0; line != "" && line.getToken(fileName, currentLineIndex, mutUInt64).item?()
            then break
        result++

func getSubBlocks(file [[UInt8]], expectedLevel UInt64, fileName [UInt8], :lineIndex UInt64, includeCAndInclude Bool) [Block]
    for
        if block .= file.getBlock(false, expectedLevel, fileName, lineIndex, includeCAndInclude); block.item?()
            then result += block[]
            else break

func getCCode(file [[UInt8]], expectedLevel UInt64, fileName [UInt8], :lineIndex UInt64) [Token]
    line := file[lineIndex]
    line.level!(expectedLevel, fileName, lineIndex)
    result += [Token]{Token{value: "C"}, Token{value: line}}
    lineIndex++
    for lineIndex != file.getLength()
        line = file[lineIndex]
        currentLevel .= line.getLevel()
        if currentLevel < expectedLevel
            then break
        result += Token{value: line}
        lineIndex++

func getCLibs(file [[UInt8]], expectedLevel UInt64, fileName [UInt8], :lineIndex UInt64) [Token]
    line := file[lineIndex]
    line.level!(expectedLevel, fileName, lineIndex)
    result += [Token]{Token{value: "include"}, Token{value: line}}
    lineIndex++
    for lineIndex != file.getLength()
        line = file[lineIndex]
        currentLevel .= line.getLevel()
        if currentLevel < expectedLevel
            then break
        result += Token{value: line}
        lineIndex++
