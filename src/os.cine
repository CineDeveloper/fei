proc makeFile(fileName [UInt8], fileData [UInt8])
    attributes
        noInline
    if < !fileData.convertTo(BinaryData).writeToFile(fileName)
        then errorCantWriteToFile(fileName)

func getCineModulePath() [UInt8]
    attributes
        alwaysInline
    result = "/opt/cine/modules/"

func getCineBinaryPath() [UInt8]
    attributes
        alwaysInline
    result = "/usr/local/bin/"

func askTheUser(flagsFile [UInt8]) [UInt8]
    attributes
        noInline
    if flagsFile.getLength() != 0
        then parse _, line <- flagsFile.asString().split('\n').getAllExceptLast()
            spaceIndex .= line.look(' ')[]
            flagName .= line.getFirstN(spaceIndex)
            description .= line.getAllExceptFirstN(spaceIndex + 1)
            print("flag: ", flagName, "\ndescription: ", description, "\n")
            for
                print("Enter \042true\042 or \042false\042.\n")
                userInput .= getLineFromSTDIN()
                if userInput == "true" || userInput == "false"
                    then
                        result:join("#define __FLAG_", flagName, " ", select(userInput == "true", "1", "0"), "\n")
                        break 2
                print("Incorrect value. Try again.\n")

func saveToTmpFile(file [UInt8], executable [UInt8]) [UInt8]
    attributes
        noInline
    result = "/tmp/".join(executable, ".c")
    if < !file.convertTo(BinaryData).writeToFile(result)
        then errorCantWriteToFile(result)

proc compileCFile(cFileName [UInt8], cCompilerOptions [UInt8], executable [UInt8])
    attributes
        noInline
    include
        #include <stdlib.h>
        #include <stdio.h>
    executableFullName .= getCineBinaryPath() + executable
    if < !systemExecute("clang ".join(cCompilerOptions, " ", cFileName, " -o ", executableFullName))
        then errorExecutableNotExist(executableFullName)
