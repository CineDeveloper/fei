proc makeFile(fileName [UInt8], fileData [UInt8])
    attributes
        noInline
    if < !fileData.convertTo(BinaryData).writeToFile(fileName)
        then errorCantWriteToFile(fileName)

func getCineModulePath() [UInt8]
    attributes
        alwaysInline
    result = "/opt/cine/modules/"

func getCineBinaryPath() [UInt8]
    attributes
        alwaysInline
    result = "/usr/local/bin/"

func askTheUser(flagsFile BinaryData) [UInt8]
    attributes
        noInline
    flags := Map([UInt8], Flag)
    position := 0
    for flagsLength := UInt64.getFromBinaryData(flagsFile, position); flagsLength != 0; flagsLength--
        name .= [UInt8].getFromBinaryData(flagsFile, position)
        flag_ .= Flag.getFromBinaryData(flagsFile, position)
        print("Flag name: ", name, "\nDescription: ", flag_.description,"\nVariants:\n")
        parse variantNumber, variant <- flag_.variants
            print("    ", variantNumber, " - ", variant, "\n")
        for
            print("Enter the variant number: ")
            if variantNumberBox .= UInt64.fromString(getLineFromSTDIN()); variantNumberBox.item?()
                then if variantNumberBox[] < flag_.variants.getLength()
                    then
                        result:join("#define __FLAG_", name, " ", variantNumberBox[].toString(), "\n")
                        break
            print("Incorrect the variant number. Try again.\n")

func saveToTmpFile(file [UInt8], executable [UInt8]) [UInt8]
    attributes
        noInline
    result = "/tmp/".join(executable, ".c")
    if < !file.convertTo(BinaryData).writeToFile(result)
        then errorCantWriteToFile(result)

proc compileCFile(cFileName [UInt8], cCompilerOptions [UInt8], executable [UInt8])
    attributes
        noInline
    executableFullName .= getCineBinaryPath() + executable
    if < !systemExecute("clang ".join(cCompilerOptions, " ", cFileName, " -o ", executableFullName))
        then errorExecutableNotExist(executableFullName)
