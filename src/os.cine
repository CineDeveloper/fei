proc makeFile(fileName [UInt8], fileData [UInt8])
    attributes
        noInline
    if < !fileData.convertTo(BinaryData).writeToFile(fileName)
        then errorCantWriteToFile(fileName)

func getFeiBinariesPath() [UInt8]
    attributes
        alwaysInline
    if pathBox .= getEnvironmentVariable("FEI_BINARIES"); > pathBox.item?()
        then result = pathBox[] + select(pathBox[].hasSuffix?("/"), "", "/")
        else errorEnvironmentVariableNotExist("FEI_BINARIES")

func getFeiResourcesPath() [UInt8]
    attributes
        alwaysInline
    if pathBox .= getEnvironmentVariable("FEI_RESOURCES"); > pathBox.item?()
        then result = pathBox[] + select(pathBox[].hasSuffix?("/"), "", "/")
        else errorEnvironmentVariableNotExist("FEI_RESOURCES")

func getFeiConfigsPath() [UInt8]
    attributes
        alwaysInline
    if pathBox .= getEnvironmentVariable("FEI_CONFIGS"); > pathBox.item?()
        then result = pathBox[] + select(pathBox[].hasSuffix?("/"), "", "/")
        else errorEnvironmentVariableNotExist("FEI_CONFIGS")

func askTheUser(flagsFile BinaryData) [UInt8]
    attributes
        noInline
    flags := Map([UInt8], Flag)
    position := 0
    for flagsLength := UInt64.getFromBinaryData(flagsFile, position); flagsLength != 0; flagsLength--
        name .= [UInt8].getFromBinaryData(flagsFile, position)
        flag_ .= Flag.getFromBinaryData(flagsFile, position)
        print("Flag name: ", name, "\nDescription: ", flag_.description,"\nVariants:\n")
        parse variantNumber, variant <- flag_.variants
            print("    ", variantNumber, " - ", variant, "\n")
        for
            print("Enter the variant number: ")
            if variantNumberBox .= UInt64.fromString(getLineFromSTDIN()); variantNumberBox.item?()
                then if variantNumberBox[] < flag_.variants.getLength()
                    then
                        result:join("#define __FLAG_", name, " ", variantNumberBox[].toString(), "\n")
                        break
            print("Incorrect the variant number. Try again.\n")

func saveToTmpFile(fileData [UInt8], fileName [UInt8]) [UInt8]
    attributes
        noInline
    result = "/tmp/" + fileName
    if < !fileData.convertTo(BinaryData).writeToFile(result)
        then errorCantWriteToFile(result)

proc compileCFile(cFileName [UInt8], cCompilerOptions [UInt8], programName [UInt8])
    attributes
        noInline
    panic(!systemExecute("clang ".join(cCompilerOptions, " ", cFileName, " -o ", getFeiBinariesPath(), programName)), "")

func loadBlocks(fileName [UInt8], includeCAndInclude Bool) [Block]
    file .= fileName.loadFile()
    if < file.empty?()
        then errorCantLoadFile(fileName)
    lines .= file[].convertTo([UInt8]).asString().split('\n')
    lineIndex := 0
    for
        if block .= lines.getBlock(true, 0, fileName, lineIndex, includeCAndInclude); block.item?()
            then result += block[]
            else break
